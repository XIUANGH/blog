# 题目

###### 题目描述

子序列是原数组中一些元素的有序集合，这些元素按照它们在原数组中的出现顺序进行选择，但不一定要相邻。现在给定一个数组 array，需要你找出该数组的最长增长子序列的长度。

###### 输入描述

第一行是一个整数 N，表示后续会有 N 行输入。每个数组占一行。

###### 输出描述

对于输入的每个数组，你需要输出其该数组最长子序列的长度。每个输出占一行。

###### 输入示例

```
1
[1,5,122,34,45,232,342,34]
```

###### 输出示例

```
6
```

###### 提示信息

```
以测试数据为例：[1,5,122,34,45,232,342,34]，把其中所有的增长子序列罗列出来。 

形成了： 

 第一个子序列：[1,5,122] 

 第二个子序列：[34,45,232,342]

 第三个子序列：[1,5,122,232,342] 

 第四个子序列：[1,5,34,45,232,342] 

 在这四个序列中，第四个序列最长，所以这个例子中，最长增长子序列的长度为 6

1 <= N < 100;
1 <= array.length < 1000.
```



## 解答

### 方法1

```java
import java.io.*;
import java.util.*;

public class Main{
    public static void main(String[] args) throws IOException{
        BufferedReader in=new BufferedReader(new InputStreamReader(System.in));
        PrintWriter out=new PrintWriter(System.out);
        String line;
        line=in.readLine();
        int n=Integer.parseInt(line);
        while(n>0){
            line=in.readLine();
            String temp=line.substring(1,line.length()-1);
            String[] arrStr=temp.split(",");
            int[] arr=new int[arrStr.length];
            for(int i=0;i<arr.length;i++){
                arr[i]=Integer.parseInt(arrStr[i]);
            }
           
            int maxLen=1;
            int[] dp=new int[arr.length];
            Arrays.fill(dp,1);
            for(int i=1;i<arr.length;i++){
                for(int j=0;j<i;j++){
                    if(arr[j]>=arr[i])continue;
                    dp[i]=Math.max(dp[i],dp[j]+1);
                }
                maxLen=Math.max(dp[i],maxLen);
            }
            out.println(maxLen);
            n--;
        }
        out.flush();
    }
}
```

使用动态规划进行求解：

`dp[i]`代表截止到i的最短子序列的长度

对于当前的`num[i]`来说，遍历i之前的全部`num[k]`：

- 如果`num[k]>=num[i]`，如果考虑了`dp[k]`，不是严格递增的序列，不可以
- 如果`num[k]<num[i]`，证明是小的，可以进行比较了，重复比较每一个出现的`dp[i]`，`dp[i]=max(dp[i],dp[k]+1)`

